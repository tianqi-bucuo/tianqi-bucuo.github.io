<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网络流</title>
    <url>/2021/05/12/%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    <content><![CDATA[<h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>给定一个包含 n 个点 m 条边的有向图，并给定每条边的容量，边的容量非负。</p>
<p>图中可能存在重边和自环。求从点 S 到点 T 的最大流。</p>
<span id="more"></span>

<p><strong>输入格式</strong></p>
<p>第一行包含四个整数 n,m,S,T。</p>
<p>接下来 m 行，每行三个整数 u,v,c，表示从点 u 到点 v 存在一条有向边，容量为 c。</p>
<p>点的编号从 1 到 n。</p>
<p><strong>输出格式</strong></p>
<p>输出点 S 到点 T 的最大流。</p>
<p>如果从点 S 无法到达点 T 则输出 0。</p>
<hr>
<p>求最大流一个比较简单的方法是使用EK(EdmondsKarp)算法: 每次通过BFS在残量网络中找到一条增广路，记录该道路中所有残量的最小值d，把这条道路上所有边的流量都增加d；然后再次BFS，直到找不到增广路。<br>EK比较暴力，每次BFS只能增广一条路径。</p>
<p>Dinic算法先通过BFS对网络分层，然后对残量网络DFS，一次DFS可以增广多条路径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn <span class="number">250</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">  <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">  vector&lt;Edge&gt; edges;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">  <span class="keyword">int</span> d[maxn], cur[maxn];   <span class="comment">// d用于分层，cur用于当前弧优化</span></span><br><span class="line">  <span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    m = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(m - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(m - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = Q.<span class="built_in">front</span>();</span><br><span class="line">      Q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">          vis[e.to] = <span class="number">1</span>;</span><br><span class="line">          d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">          Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      Edge&amp; e = edges[G[x][i]];</span><br><span class="line">      <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        e.flow += f;</span><br><span class="line">        edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">        flow += f;</span><br><span class="line">        a -= f;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">    <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">      flow += <span class="built_in">DFS</span>(s, INF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><p>给出一个包含 n 个点和 m 条边的有向图（下面称其为网络） G=(V,E)，该网络上所有点分别编号为 1∼n，所有边分别编号为 1∼m，其中该网络的源点为 s，汇点为 t，网络上的每条边 (u,v) 都有一个流量限制 w(u,v) 和单位流量的费用 c(u,v)。你需要给每条边 (u,v) 确定一个流量 f(u,v)，要求：在流量最大的前提下费用最小。</p>
<p><strong>输入格式</strong></p>
<p>输入第一行包含四个整数 n,m,s,t，分别代表该网络的点数 n，网络的边数 m，源点编号 s，汇点编号 t。</p>
<p>接下来 m 行，每行四个整数 u、v、w、c，分别代表第 i 条边的起点，终点，流量限制，单位流量费用。</p>
<p><strong>输出格式</strong></p>
<p>输出两个整数，分别为该网络的最大流 F(G)，以及在 F(G) 最大的前提下，该网络的最小费用 C(G)。</p>
<hr>
<p>最大流增广时用BFS随便找到一个增广路即可，但是最小费用流要求费用最小，这时候就不能用BFS随便找了。</p>
<p>将费用作为边权，找一条从源点S到汇点T的最短路径，按照这条路径进行增广就能保证花费的费用最小。</p>
<p>找单源最短路径有Dijkstra和SPFA(Bellman-Ford)，但因为残量网络中有反向边，反向边的费用cost初始时等于-cost，也就是肯定存在负权边，所以只能用SPFA(好像Dijkstra改一下也能用)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>, MAXM = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> maxFlow, minCost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MCMF</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> inq[MAXN];</span><br><span class="line">    <span class="keyword">int</span> d[MAXN];</span><br><span class="line">    <span class="keyword">int</span> p[MAXN];</span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>, cost));</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>, -cost));</span><br><span class="line">        m = edges.<span class="built_in">size</span>();</span><br><span class="line">        G[from].<span class="built_in">push_back</span>(m<span class="number">-2</span>);</span><br><span class="line">        G[to].<span class="built_in">push_back</span>(m<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">          d[i] = INF;</span><br><span class="line">        <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">        d[s] = <span class="number">0</span>; inq[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = INF;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            inq[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost) &#123;</span><br><span class="line">                    d[e.to] = d[u] + e.cost;</span><br><span class="line">                    p[e.to] = G[u][i];</span><br><span class="line">                    a[e.to] = <span class="built_in">min</span>(a[u], e.cap - e.flow);</span><br><span class="line">                    <span class="keyword">if</span> (!inq[e.to]) &#123;</span><br><span class="line">                        Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                        inq[e.to] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[t] == INF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        maxFlow += a[t];</span><br><span class="line">        minCost += d[t] * a[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">            edges[p[u]].flow += a[t];</span><br><span class="line">            edges[p[u]^<span class="number">1</span>].flow -= a[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MincostMaxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">SPFA</span>(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  n, m, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    MCMF mcmf;</span><br><span class="line">    mcmf.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">int</span> u, v, capacity, cost;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; capacity &gt;&gt; cost;</span><br><span class="line">        mcmf.<span class="built_in">addEdge</span>(u, v, capacity, cost);</span><br><span class="line">    &#125;</span><br><span class="line">    mcmf.<span class="built_in">MincostMaxflow</span>(s, t);</span><br><span class="line">    cout &lt;&lt; maxFlow &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;minCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图匹配</title>
    <url>/2021/05/15/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>有两种情况的二分图匹配，一种是无权二分图，称为<strong>二分图最大匹配</strong>；一种是带权二分图，称为<strong>二分图最大权匹配</strong>。</p>
<span id="more"></span>

<h2 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h2><p><strong>题目描述</strong></p>
<p>给定一个二分图，其左部点的个数为 n，右部点的个数为 m，边数为 e，求其最大匹配的边数。</p>
<p>左部点从 1 至 n 编号，右部点从 1 至 m 编号。</p>
<p><strong>输入格式</strong></p>
<p>输入的第一行是三个整数，分别代表 n，m 和 e。</p>
<p>接下来 e 行，每行两个整数 u,v，表示存在一条连接左部点 u 和右部点 v 的边。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个整数，代表二分图最大匹配的边数。</p>
<hr>
<h3 id="1-匈牙利算法"><a href="#1-匈牙利算法" class="headerlink" title="1.匈牙利算法"></a>1.匈牙利算法</h3><p>解决这个问题比较常用的方法是匈牙利算法。</p>
<p>在匈牙利算法里有一个<strong>增广路</strong>的概念：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边、匹配边……所得到的路径称为交替路。如果交替路的终点是一个未匹配点，则称这条交替路为一条增广路。</p>
<p>这个增广路和网络流里的增广路稍微有些区别。</p>
<p>匈牙利算法具体流程如下：</p>
<ul>
<li>初始状态所有边都是非匹配边</li>
<li>一次从一个左部 u 开始，尝试 dfs 寻找增广路，记 u 出发到达的右部节点为 v ，记 lft[i] 为匹配右部节点 i 的左部节点。<ul>
<li>若 u 能到达的右部节点 v 为非匹配点，则找到一条长度为 1 的增广路，lft[v] = u</li>
<li>若 v 为匹配点，则递归地从 lft[v] 出发寻找增广路，回溯时记 lft[v] = u </li>
<li>在同一次增广中，若 v 曾经被到达过，则跳过(非简单路)</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, e;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> lft[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : edges[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!lft[v] || <span class="built_in">dfs</span>(lft[v])) &#123;</span><br><span class="line">                lft[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt;e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v; e; --e) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;            </span><br><span class="line">        edges[u].<span class="built_in">push_back</span>(v);            </span><br><span class="line">    &#125;        </span><br><span class="line">		</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(i))</span><br><span class="line">            ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度$O(nm)$，n 为节点数，m 为边数。</p>
<h3 id="2-转为网络最大流模型"><a href="#2-转为网络最大流模型" class="headerlink" title="2. 转为网络最大流模型"></a>2. 转为网络最大流模型</h3><p>二分图最大匹配可以转换成网络流模型。</p>
<p>将左边所有点接上源点，右边所有点接上汇点，容量皆为 1 。原来的每条边从左往右连边，容量也皆为 1 ，最大流即最大匹配。</p>
<p>如果使用 Dinic 算法求该网络的最大流，可在$O(\sqrt{n}m)$求出。</p>
<h2 id="二分图最大权匹配"><a href="#二分图最大权匹配" class="headerlink" title="二分图最大权匹配"></a>二分图最大权匹配</h2><p><strong>题目描述</strong></p>
<p>给定一张二分图，左右部均有 n 个点，共有 m 条带权边，且保证有完美匹配。<br>求一种完美匹配的方案，使得最终匹配边的边权之和最大。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数 n, m，第 2 ∼ m+1 行，每行三个整数 u， v，w 描述了图中的一条边，从左部的 u 到右部的 v ，边权为 w 。</p>
<p><strong>输出格式</strong></p>
<p>第一行一个整数表示答案。<br>第二行共 nn 个整数 a1，a2，a3…an ，其中 ai 表示完美匹配下与右部第 i 个点相匹配的左部点的编号。如果存在多种方案，请输出任意一种。</p>
<hr>
<h3 id="1-Kuhn-Munkres算法"><a href="#1-Kuhn-Munkres算法" class="headerlink" title="1. Kuhn-Munkres算法"></a>1. Kuhn-Munkres算法</h3><p>无权二分图匹配里用了匈牙利算法，KM算法里也有匈牙利算法找增广路的思想。</p>
<p>KM里有一个比较(很)难理解的概念：<strong>顶标</strong><br>可行顶标是一个节点函数 l ，使得对于任意弧(u,v)，有 l(u)+l(v)≥w(u,v)。<br>(定义看完一脸懵 ~ ~ ~)</p>
<p>KM也像匈牙利算法一样，不断地向图中添加匹配边，最终达到完美匹配。顶标的作用是当添加匹配边冲突时，用于帮助做出正确的贪心选择的。<br>例如，左部顶点 u1、u2 按照算法流程都连向了右部节点 v ，顶标就是用来计算 u1、u2 哪个更应该与 v 相连，然后让另一个去连别的右部节点。</p>
<p>KM算法流程：</p>
<p>1.贪心地初始化可行顶标的值<br>2.用匈牙利算法寻找匹配<br>3.如果在找匹配的过程中出现了冲突，修改顶标的值<br>4.重复2、3步</p>
<p>第一步初始化顶标，将左部节点的顶标值初始化为它所连的边中的最大权值，将右部节点的顶标值全部初始化为 0 。<br>这步就是将左部节点要连的边先假设为可能的最大值，后面如果冲突，再修改顶标让它匹配其他的边。</p>
<p>第二步和无权二分图类似，从一个左部节点向右部节点连边，如果 l(u)+l(v)=w(u,v)，就是匹配到了正确的右部节点。</p>
<p>第三步如果要匹配的右部节点已经被匹配，就要修改顶标值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>, maxm = <span class="number">500000</span>, inf = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W[maxn][maxn], n, m;    <span class="comment">// 边的权值</span></span><br><span class="line"><span class="keyword">int</span> lx[maxn], ly[maxn];     <span class="comment">// 节点的顶标</span></span><br><span class="line"><span class="keyword">int</span> lft[maxn];              <span class="comment">// 右部节点匹配的左部节点</span></span><br><span class="line"><span class="keyword">bool</span> S[maxn], T[maxn];      <span class="comment">// 记录本次匹配中节点是否被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    S[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lx[i] + ly[j] == W[i][j] &amp;&amp; !T[j]) &#123;</span><br><span class="line">            T[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!lft[j] || <span class="built_in">match</span>(lft[j])) &#123;</span><br><span class="line">                lft[j] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改顶标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!T[j]) &#123;</span><br><span class="line">                    a = <span class="built_in">min</span>(a, lx[i] + ly[j] - W[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i])   lx[i] -= a;</span><br><span class="line">        <span class="keyword">if</span> (T[i])   ly[i] += a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        lft[i] = lx[i] = ly[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) </span><br><span class="line">            lx[i] = <span class="built_in">max</span>(lx[i], W[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) S[j] = T[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">match</span>(i))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="built_in">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w; m; m--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        W[u][v] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">KM</span>();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        res += W[lft[i]][i];</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        cout &lt;&lt; lft[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照下面的二分图走一遍算法流程</p>
<ol>
<li><p>初始化顶标为最大权值<br><img src="/2021/05/15/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/1.png"></p>
</li>
<li><p>u1 成功匹配 v1<br><img src="/2021/05/15/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/2.png"></p>
</li>
<li><p>u2 也想匹配 v1<br><img src="/2021/05/15/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/3.png"><br>这时候就发生了冲突，那咋办————修改顶标。<br>修改顶标的目的是判断 u1、u2 哪个更应该与 v1 相连。<br>分别遍历 u1、u2 与除 v1 外其他右部节点相连所能得到的边权，用 w(u1,v1)和 w(u2,v1) 分别减去这些边权，取最小值，就是应该修改的顶标值。<br>其实就是看一看 u1、u2 哪个不与 v1 相连损失的边权最小，损失较小的那个让它去连别的右部节点(贪心)。</p>
</li>
<li><p>修改顶标后 u2 与 v2 相连<br><img src="/2021/05/15/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/4.png"></p>
</li>
<li><p>v1 顶标修改后 u3 无法与任何节点相连，就得修改顶标<br><img src="/2021/05/15/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/5.png"></p>
</li>
<li><p>修改后的 u3 想连 v1 ，又冲突了，那就再修改顶标<br><img src="/2021/05/15/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/6.png"></p>
</li>
<li><p>修改后所有节点都完成匹配<br><img src="/2021/05/15/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/7.png"><br>都满足 l(u)+l(v)=w(u,v)</p>
</li>
</ol>
<p>这个版本的KM算法时间复杂度为$O(n^4)$，另外有可以优化到$O(n^3)$的版本。</p>
<h3 id="2-转化为费用流模型"><a href="#2-转化为费用流模型" class="headerlink" title="2. 转化为费用流模型"></a>2. 转化为费用流模型</h3><p>在图中新增一个源点和一个汇点。</p>
<p>从源点向二分图的每个左部点连一条流量为 1 ，费用为 0 的边，从二分图的每个右部点向汇点连一条流量为 1 ，费用为 0 的边。</p>
<p>接下来对于二分图中每一条连接左部点 u 和右部点 v ，边权为 w 的边，则连一条从 u 到 v ，流量为 1 ，费用为 w 的边。</p>
<p>求这个网络的 <strong>最大费用最大流</strong> 即可得到答案。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图的匹配</tag>
      </tags>
  </entry>
</search>
