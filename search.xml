<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>最大流</title>
    <url>/2021/05/12/%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    <content><![CDATA[<p>求最大流一个比较简单的方法是使用EK(EdmondsKarp)算法: 每次通过BFS找到一条增广路，记录该道路中所有残量的最小值d，把这条道路上所有边的流量都增加d；然后再次BFS，直到找不到增广路。<br>EK比较暴力，每次BFS只能增广一条路径。</p>
<span id="more"></span>

<p>Dinic算法先通过BFS对图分层，然后对残量网络DFS，一次DFS可以增广多条路径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="comment">// 邻接表存储</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> head[maxn], cnt;</span><br><span class="line">    <span class="keyword">int</span> depth[maxn];</span><br><span class="line">    Edge edges[maxm];</span><br><span class="line">    <span class="keyword">int</span> S, T, N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        S = T = N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edges[cnt].u = u, edges[cnt].v = v, edges[cnt].w = w;</span><br><span class="line">        edges[cnt].next = head[u];  head[u] = cnt++;</span><br><span class="line">        edges[cnt].u = v, edges[cnt].v = u, edges[cnt].w = <span class="number">0</span>;</span><br><span class="line">        edges[cnt].next = head[v], head[v] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            depth[i] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(S);   depth[S] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.<span class="built_in">front</span>();    q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].next) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edges[i].v, w = edges[i].w;</span><br><span class="line">                <span class="keyword">if</span> (w &gt; <span class="number">0</span> &amp;&amp; depth[u] + <span class="number">1</span> &lt; depth[v]) &#123;</span><br><span class="line">                    depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth[T] != inf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> minw)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == T) <span class="keyword">return</span> minw;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; ~i; i = edges[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edges[i].v, w = edges[i].w;</span><br><span class="line">            <span class="keyword">if</span> (w &lt;= <span class="number">0</span> || depth[v] != depth[s] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cw = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(w, minw));</span><br><span class="line">            <span class="keyword">if</span> (cw &lt;= <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">            edges[i].w -= cw;</span><br><span class="line">            edges[i^<span class="number">1</span>].w += cw;</span><br><span class="line">            <span class="keyword">return</span> cw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">int</span> d = <span class="built_in">dfs</span>(S, inf)) &#123;</span><br><span class="line">                ret += d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, S, T;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    Dinic d;</span><br><span class="line">    d.<span class="built_in">init</span>(); d.S = S; d.T = T; d.N = n;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        d.<span class="built_in">addEdge</span>(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; d.<span class="built_in">dinic</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
</search>
